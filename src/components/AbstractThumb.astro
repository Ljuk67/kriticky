---
interface Props {
  width?: number | string;
  height?: number | string;
  seed?: string;
}

const { width = "100%", height = 220, seed = 'default' } = Astro.props as Props;
// Numeric drawing space for viewBox and geometry
const drawW: number = typeof width === 'number' ? width : 720;
const drawH: number = typeof height === 'number' ? height : 360;

// Simple string hash → seeded PRNG for deterministic output per post
function hashString(str: string): number {
  let h = 2166136261 >>> 0;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
  }
  return h >>> 0;
}

function mulberry32(a: number) {
  return function () {
    let t = (a += 0x6D2B79F5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

const rnd = mulberry32(hashString(String(seed)));

// Grayscale palette (vary only lightness)
const grays = [18, 26, 34, 46, 58, 72];
const palette = grays.map((l) => `hsl(0 0% ${l}%)`);

const bgLight = 94 + Math.floor(rnd() * 4); // 94–97% light
const bg = `hsl(0 0% ${bgLight}%)`;

// Generate fewer, larger shapes for a zoomed-in, partial look
const shapesCount = 4 + Math.floor(rnd() * 3); // 4–6

// Helper for extended range to allow partial cut-offs
const ex = {
  x: (pad = 0.2) => -drawW * pad + rnd() * (drawW * (1 + 2 * pad)),
  y: (pad = 0.2) => -drawH * pad + rnd() * (drawH * (1 + 2 * pad)),
};

type Circle = { type: 'circle'; cx: number; cy: number; r: number; fill: string; opacity: number };
type Rect = { type: 'rect'; x: number; y: number; w: number; h: number; rot: number; fill: string; opacity: number };
type Poly = { type: 'poly'; points: Array<[number, number]>; fill: string; opacity: number };

const shapes: Array<Circle | Rect | Poly> = Array.from({ length: shapesCount }).map(() => {
  const tone = palette[Math.floor(rnd() * palette.length)];
  const opacity = 0.45 + rnd() * 0.35; // 0.45–0.80
  const t = rnd();
  if (t < 0.4) {
    // Large circle
    const r = Math.max(drawW, drawH) * (0.25 + rnd() * 0.35); // big radius
    return { type: 'circle', cx: ex.x(0.35), cy: ex.y(0.35), r, fill: tone, opacity: Number(opacity.toFixed(2)) };
  } else if (t < 0.75) {
    // Rotated rectangle
    const w = Math.max(drawW, drawH) * (0.35 + rnd() * 0.4);
    const h = Math.max(drawW, drawH) * (0.18 + rnd() * 0.3);
    const x = ex.x(0.35);
    const y = ex.y(0.35);
    const rot = Math.floor(rnd() * 360);
    return { type: 'rect', x, y, w, h, rot, fill: tone, opacity: Number(opacity.toFixed(2)) };
  } else {
    // Triangle/polygon with 3-4 points
    const ptsCount = 3 + Math.floor(rnd() * 2);
    const points: Array<[number, number]> = Array.from({ length: ptsCount }).map(() => [ex.x(0.35), ex.y(0.35)] as [number, number]);
    return { type: 'poly', points, fill: tone, opacity: Number(opacity.toFixed(2)) };
  }
});
---

<svg
  class="thumb"
  xmlns="http://www.w3.org/2000/svg"
  viewBox={`0 0 ${drawW} ${drawH}`}
  width={typeof width === 'number' ? width : undefined}
  height={typeof height === 'number' ? height : undefined}
  style={typeof width === 'string' || typeof height === 'string' ? `width: ${typeof width === 'string' ? width : drawW + 'px'}; height: ${typeof height === 'string' ? height : 'auto'};` : undefined}
  role="img"
  aria-label="Abstraktný geometrický náhľad"
  preserveAspectRatio="xMidYMid slice"
>
  <defs>
    <linearGradient id="bg-grad" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0%" stop-color={bg} />
      <stop offset="100%" stop-color={`hsl(0 0% ${Math.max(88, bgLight - 6)}%)`} />
    </linearGradient>
    <filter id="soften" x="-20%" y="-20%" width="140%" height="140%">
      <feGaussianBlur stdDeviation="2.5" />
    </filter>
    <clipPath id="rounded">
      <rect x="0" y="0" width={drawW} height={drawH} rx={Math.min(drawW, drawH) * 0.06} ry={Math.min(drawW, drawH) * 0.06} />
    </clipPath>
  </defs>

  <g clip-path="url(#rounded)">
    <rect x="0" y="0" width={drawW} height={drawH} fill="url(#bg-grad)" />
    {shapes.map((s) => (
      s.type === 'circle' ? (
        <circle cx={s.cx} cy={s.cy} r={s.r} fill={s.fill} opacity={s.opacity} />
      ) : s.type === 'rect' ? (
        <g transform={`translate(${s.x} ${s.y}) rotate(${s.rot})`}>
          <rect x={-s.w / 2} y={-s.h / 2} width={s.w} height={s.h} fill={s.fill} opacity={s.opacity} />
        </g>
      ) : (
        <polygon points={s.points.map(([x,y]) => `${x},${y}`).join(' ')} fill={s.fill} opacity={s.opacity} />
      )
    ))}
  </g>
</svg>

<style>
  .thumb { display: block; border-radius: 12px; margin-bottom: 15px; margin: 0px auto; }
</style>
